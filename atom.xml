<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>云翔天下</title>
  
  <subtitle>总要留下一些存在的痕迹罢</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.geetry.com/"/>
  <updated>2018-05-06T11:37:21.263Z</updated>
  <id>http://www.geetry.com/</id>
  
  <author>
    <name>流水殇</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>布隆过滤器介绍和应用</title>
    <link href="http://www.geetry.com/2018/03/29/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>http://www.geetry.com/2018/03/29/布隆过滤器介绍和应用/</id>
    <published>2018-03-29T10:08:47.000Z</published>
    <updated>2018-05-06T11:37:21.263Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>在日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是要判断 它是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上；在网络爬虫里，一个网址是否被访问过等等。<br>最直接的方法就是将集合中全部的元素存在计算机中，遇到一个新元素时，将它和集合中的元素直接比较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的好处是快速准确，缺点是费存储空间（因为要同时存储key和value，加上需要解决哈希碰撞，所以实际空间效率&lt;50%）。当集合比较小时，这个问题不显著，但是当集合巨大时，哈希表存储效率低的问题就显现出来了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹（详见：数学之美之信息指纹）， 然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法存储的。<br>今天我们就介绍一个一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p><a id="more"></a><h1 id="布隆过滤器介绍"><a href="#布隆过滤器介绍" class="headerlink" title="布隆过滤器介绍"></a>布隆过滤器介绍</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果想判断一个元素是不是在一个集合里，一般想到的是将集合中所有元素保存起来，然后通过比较确定。链表、树、散列表（又叫哈希表，Hash table）等等数据结构都是这种思路。但是随着集合中元素的增加，我们需要的存储空间越来越大。同时检索速度也越来越慢。<br>Bloom Filter 是一种空间效率很高的随机数据结构，Bloom filter 可以看做是对 bit-map 的扩展, 它的基本原理是：当一个元素被加入集合时，通过 K 个 Hash 函数将这个元素映射成一个位阵列（Bit array）中的 K 个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：</p><ol><li>如果这些点有任何一个 0，则被检索元素一定不在；</li><li>如果都是 1，则被检索元素很可能在（存在误判率，下文会详解）。</li></ol><img title="布隆过滤器原理图" alt="布隆过滤器原理图" src="http://p24hn6n30.bkt.clouddn.com/static/images/boolmfilter1.png-blogImg"><p>如上图可知布隆过滤器的重点有两个：</p><ol><li>一个bit数组，用来存放映射信息</li><li>多个Hash函数，用来将元素映射到bit数组<br>布隆过滤器背后的数学原理在于两个完全随机的数学冲突峰概率很小，因此，可以在很小的无识别率的条件下，用很小的空间存储大量的信息。</li></ol><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数。另外, Hash 函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。</li><li>布隆过滤器可以表示全集，其它任何数据结构都不能。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>但是布隆过滤器的缺点和优点一样明显。误算率（False Positive）是其中之一。随着存入的元素数量增加，误算率随之增加(误判补救方法是：再建立一个小的白名单，存储那些可能被误判的信息。)。但是如果元素数量太少，则使用散列表足矣。<br>另外，一般情况下不能从布隆过滤器中删除元素. 我们很容易想到把位列阵变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全的删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面. 这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。</p><h1 id="布隆过滤器的应用场景"><a href="#布隆过滤器的应用场景" class="headerlink" title="布隆过滤器的应用场景"></a>布隆过滤器的应用场景</h1><p>布隆过滤器决不会漏掉任何一个在黑名单中的可疑地址。但是，它有一条不足之处。比如，它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名单中，因为有可能某个好的邮件地址正巧对应个八个都被设置成一的二进制位。好在这种可能性很小。我们把它称为误识概率。</p><h2 id="不能接受误报的场景"><a href="#不能接受误报的场景" class="headerlink" title="不能接受误报的场景"></a>不能接受误报的场景</h2><p>以注册用户的例子为例，我们利用布隆过滤器建立以注册的用户名单，判断用户是否可注册，会按照以下步骤执行:</p><ol><li>传入注册用户的通行证，根据我们建立的已注册用户的布隆过滤器，查询该用户是否存在布隆过滤器中。</li><li>假设该用户不存在布隆过滤器的集合，对于元素不在集合的结果，布隆过滤器是不会误报，所以可以放心返回该用户可以成功注册的结果。</li><li>假设用户存在于布隆过滤器，对于元素在集合的结果，布隆过滤器有可能误报，所以我们还需要再查询下真正的数据库，确认用户是否真的已注册了。</li></ol><h2 id="可以接受误报的场景"><a href="#可以接受误报的场景" class="headerlink" title="可以接受误报的场景"></a>可以接受误报的场景</h2><p>对于垃圾邮件的黑名单过滤，它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名单中。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p><h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><ol><li>chrome、360危险网站识别</li><li>垃圾邮箱识别</li><li>爬虫URL去重</li><li>解决缓存穿透问题</li><li>……</li></ol><h1 id="布隆过滤器在java中的使用"><a href="#布隆过滤器在java中的使用" class="headerlink" title="布隆过滤器在java中的使用"></a>布隆过滤器在java中的使用</h1><p>接下来我将演示如何使用guava中封装的布隆过滤器算法以及说明其误判率。</p><h2 id="创建代码工程"><a href="#创建代码工程" class="headerlink" title="创建代码工程"></a>创建代码工程</h2><ol><li>新建一个maven工程，然后在pom中引入guava的依赖：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;19.0&lt;/version&gt;  //版本在18以上才提供了布隆过滤器算法</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><ol><li>新建一个测试类<code>BoolmFilterTest</code>,编写如下代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoolmFilterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> insertions = <span class="number">1000000</span>;<span class="comment">//100w</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化一个存储String数据的布隆过滤器，初始化大小为100w</span></span><br><span class="line">        BloomFilter&lt;String&gt; bloomFilter =</span><br><span class="line">                BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions,<span class="number">0.01</span>);</span><br><span class="line">        <span class="comment">//初始化一个存储String数据的set，初始化大小为100w，做验证参考</span></span><br><span class="line">        Set&lt;String&gt; sets = <span class="keyword">new</span> HashSet&lt;String&gt;(insertions);</span><br><span class="line">        <span class="comment">//初始化一个存储String数据额list，初始化大小为100w</span></span><br><span class="line">        List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;String&gt;(insertions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向三个容器中初始化100w个随机唯一的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; insertions; i++) &#123;</span><br><span class="line">            String uuid = UUID.randomUUID().toString();</span><br><span class="line">            bloomFilter.put(uuid);</span><br><span class="line">            sets.add(uuid);</span><br><span class="line">            lists.add(uuid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//布隆过滤器误判的次数</span></span><br><span class="line">        <span class="keyword">int</span> wrongCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//布隆过滤器正确地次数</span></span><br><span class="line">        <span class="keyword">int</span> rightCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//随机抽取1w数据做验证</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            String test = i % <span class="number">100</span> == <span class="number">0</span> ? lists.get(i / <span class="number">100</span>) : UUID.randomUUID().toString();</span><br><span class="line">            <span class="comment">//布隆过滤器验证通过</span></span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(test)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sets.contains(test))</span><br><span class="line">                    rightCount++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    wrongCount++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"right count : "</span> + rightCount);</span><br><span class="line">        System.out.println(<span class="string">"wrong count : "</span>+wrongCount);</span><br><span class="line">        System.out.println(<span class="string">"wrong rate : "</span>+Math.round(((wrongCount*<span class="number">1.0</span>)/(<span class="number">9900</span>))*<span class="number">100</span>)+<span class="string">"%"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其中<code>insertions</code>表示我们全量数据的大小（但实际bit数组的长度和hash算法的个数都是不定的，根据误判率动态调整）。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BloomFilter&lt;String&gt; bloomFilter =</span><br><span class="line">        BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), insertions,<span class="number">0.01</span>);</span><br></pre></td></tr></table></figure><p></p><p>这一行代码建立一个布隆过滤器，工厂方法有三个参数，分别表示过滤器的类型，容量大小，误判率（没错，你可以指定误判率，但是千万别写0，默认是0.03）。<br>接下来我们以100万随机字符串为数据源介绍布隆过滤器的使用以及统计其误判率。</p><img title="布隆过滤器测试" alt="布隆过滤器测试" src="http://p24hn6n30.bkt.clouddn.com/static/images/boolmfilter2.png-blogImg"><p>由结果可以看到布隆过滤器说不过的确实不过，但是它说过的不一定真的是对的，这就是误判的情况，总体上实际误判率与我们期望的是一致的。<br>我们再来看看算法内部调整的数组长度和hash函数的个数：</p><img title="布隆过滤器算法细节" alt="布隆过滤器算法细节" src="http://p24hn6n30.bkt.clouddn.com/static/images/boolmfilter3.png-blogImg"><p>可以看到为了达到我们要求的误判率，算法包实际创建的bit数组的长度是 9585058，Hash函数的个数是7个，具体为什么是这些数字，可以查看这篇论文了解：<br><code>http://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives</code></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我们首先介绍了布隆过滤器的基本原理、优势劣势、使用场景；然后利用guava提供的算法包展示了字符串的判断和测试，并验证了它的误判率。布隆过滤器在行业应用比较广泛，感谢google的工程师为我们提供了好用的算法包。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html" target="_blank" rel="noopener">https://www.cnblogs.com/haippy/archive/2012/07/13/2590351.html</a></li><li><a href="https://segmentfault.com/a/1190000002729689" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002729689</a></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;在日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是要判断 它是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑名单上；在网络爬虫里，一个网址是否被访问过等等。&lt;br&gt;最直接的方法就是将集合中全部的元素存在计算机中，遇到一个新元素时，将它和集合中的元素直接比较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的好处是快速准确，缺点是费存储空间（因为要同时存储key和value，加上需要解决哈希碰撞，所以实际空间效率&amp;lt;50%）。当集合比较小时，这个问题不显著，但是当集合巨大时，哈希表存储效率低的问题就显现出来了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的具体办法是将每一个 email 地址对应成一个八字节的信息指纹（详见：数学之美之信息指纹）， 然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法存储的。&lt;br&gt;今天我们就介绍一个一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.geetry.com/categories/java/"/>
    
    
      <category term="布隆过滤器" scheme="http://www.geetry.com/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>java9初探</title>
    <link href="http://www.geetry.com/2018/03/09/java9%E5%88%9D%E6%8E%A2/"/>
    <id>http://www.geetry.com/2018/03/09/java9初探/</id>
    <published>2018-03-09T02:34:11.000Z</published>
    <updated>2018-05-06T11:37:21.262Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>java自1995年诞生到现在已经23岁了，在这么长的时间里，java的每个版本都会带来快一些新的特性，同时还要保持对旧版本的兼容性，因此java的运行时也变得非常臃肿和庞大，运行时依赖的rt.jar单个文件就有60多M，即使你只是想运行一个简单地helloword,你也不得不加载高达60M+的依赖包。随着微服务和自动化运维的兴起，人们讲究的是快速、精细部署，老态龙钟的java却总是差强人意。<br>可以说java9的出现更多的是为了改善这些问题，提升java的竞争力。个人认为java9最大的改善在以下几个方面：</p><ol><li>模块化，避免泛滥的代码依赖和说不清道不明的误用。</li><li>Jlink打包，可以生成一个最小依赖的Image，减少包的大小，轻量部署。</li><li>提供了类似JShell的新的工具和新的编程API。</li></ol><a id="more"></a><p>本篇文章主要目的是对java9的新特性做一个初探。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>java9的安装包可以从<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk9-downloads-3848520.html" target="_blank" rel="noopener">这里下载</a>。<br>安装步骤与之前的版本没有什么差别，记得设置java的环境变量哦。<br>安装完成后控制台输入<code>java -version</code> 如果有显示java的版本为9，那说明已经安装成功。</p><h1 id="文件结构变化"><a href="#文件结构变化" class="headerlink" title="文件结构变化"></a>文件结构变化</h1><p>我们先看看java9的目录结构：</p><img title="目录结构" alt="目录结构" src="http://p24hn6n30.bkt.clouddn.com/static/images/java9-1-2.png-blogImg"><p>可以看到相比java8多了一些目录,其中最重要的是<code>jmods</code>这个文件夹，里面包含了java9内置的系统模块，而且采用了新的文件格式-jomd。这些文件有什么用呢？其实可以看做是rt.jar的替代，java9的lib里面不再有rt.jar这个巨无霸，而是提供更细粒度的一个个的模块，想用哪个就引用哪个，在使用jlink打包优化的时候会把没有用到的依赖都去掉，仅仅保留一个最小依赖的运行包，是不是很适合微服务和容器部署？<br>我们可以在控制台输入命令<code>java --list-modues</code>来查看所有系统提供的基础模块，应该是94个模块。</p><h1 id="Jshell"><a href="#Jshell" class="headerlink" title="Jshell"></a>Jshell</h1><p>我们都知道Ruby,Scala,Groovy,Clojure都有提供一个REPL工具，<br>这个工具可以让使用者快速的了解语言的特性，现在java9也有了这样的工具-Jshell。<br>java9安装成功后，打开控制台输入<code>jshell</code>便可开启这个工具，我们可以简单地测试一下<br><img title="jshell" alt="jshell测试" src="http://p24hn6n30.bkt.clouddn.com/static/images/java9-1-1.png-blogImg"><br>更多详细的用法可以<a href="https://www.cnblogs.com/IcanFixIt/p/6690478.html" target="_blank" rel="noopener">参考这里</a>。</p><h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>java9最大的改变应该就是模块化了，回想我们以前的版本，把一个jar放到classpath中，那么实际所有的第三方都可以访问里面的public的类和方法，即使某个类、某个方法是不想被外界使用的，你毫无办法去控制你的公开的类不被别人访问，还记得Oracle为了不让开发者使用”sun“这个包所做的<a href="http://web.archive.org/web/19980215011039/http://java.sun.com/products/jdk/faq/faq-sun-packages.html" target="_blank" rel="noopener">人工声明</a>么？<br>现在java9来了，这已经不是一个问题，模块可的可用性具体体现在两个方面：可读的、可访问的。如果一个模块在我的modulePath（注意，不是classPath）中，那么这个模块对我来说是可读的；但是我能访问这个模块里面的哪些类呢，那是模块的开发者决定的。<br>每个模块都有一个模块描述文件<code>module-info.java</code>（没错这不是一个合法的类名称，他们故意这样的），类似nodejs的package.json,文件里面定义了我要requires哪些模块，我exports哪些模块给别人用。我没有exports的类你即使添加了对该模块的依赖依然是无法访问的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> packt.addressbook &#123;</span><br><span class="line"><span class="keyword">requires</span> packt.sortutil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> packt.sortutil &#123;</span><br><span class="line"><span class="keyword">exports</span> packt.util;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我会在后续详细讲解模块的使用。</p><h1 id="Jlink"><a href="#Jlink" class="headerlink" title="Jlink"></a>Jlink</h1><p>Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的JDK模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。使得JDK可以在更小的设备中使用。采用模块化系统的应用程序只需要这些应用程序所需的那部分JDK模块，而非是整个JDK框架了。</p><h1 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h1><p>JDK9之前提供HttpURLConnection API来实现Http访问功能，但是这个类基本很少使用，一般都会选择Apache的Http Client，此次在Java 9的版本中引入了一个新的package:java.net.http，里面提供了对Http访问很好的支持，不仅支持Http1.1而且还支持<a href="https://mp.weixin.qq.com/s/jBOky6nld7XxZFecd7mIgA" target="_blank" rel="noopener">HTTP2</a>，以及WebSocket，据说性能特别好。</p><h1 id="不可变集合工厂方法"><a href="#不可变集合工厂方法" class="headerlink" title="不可变集合工厂方法"></a>不可变集合工厂方法</h1><p>Java 9增加了List.of()、Set.of()、Map.of()和Map.ofEntries()等工厂方法来创建不可变集合。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List strs = List.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">List strs List.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Set strs = Set.of(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">Set ints = Set.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Map maps = Map.of(<span class="string">"Hello"</span>, <span class="number">1</span>, <span class="string">"World"</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p></p><p>除了更短和更好阅读之外，这些方法也可以避免您选择特定的集合实现。在创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。</p><h1 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h1><p>Java8为我们提供了接口的默认方法和静态方法，接口也可以包含行为，而不仅仅是方法定义。<br>默认方法和静态方法可以共享接口中的私有方法，因此避免了代码冗余，这也使代码更加清晰。如果私有方法是静态的，那这个方法就属于这个接口的。并且没有静态的私有方法只能被在接口中的实例调用。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">InterfaceWithPrivateMethods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">staticPrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"static private"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">instancePrivate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"instance private"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">        String result = staticPrivate();</span><br><span class="line">        InterfaceWithPrivateMethods pvt = <span class="keyword">new</span> InterfaceWithPrivateMethods() &#123;</span><br><span class="line">            <span class="comment">// anonymous class 匿名类</span></span><br><span class="line">        &#125;;</span><br><span class="line">        result = pvt.instancePrivate();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h1 id="多版本兼容"><a href="#多版本兼容" class="headerlink" title="多版本兼容"></a>多版本兼容</h1><p>当一个新版本的 Java 出现的时候，你的库用户要花费很长时间才会切换到这个新的版本。这就意味着库要去向后兼容你想要支持的最老的 Java 版本 (许多情况下就是 Java 6 或者 7)。这实际上意味着未来的很长一段时间，你都不能在库中运用 Java 9 所提供的新特性。幸运的是，多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本：<br><img title="多版本" alt="多版本" src="http://p24hn6n30.bkt.clouddn.com/static/images/java9-1-3.png-blogImg"><br>在上述场景中， multirelease.jar 可以在 Java 9 中使用, 不过 Helper 这个类使用的不是顶层的 multirelease.Helper 这个 class, 而是处在“META-INF/versions/9”下面的这个。这是特别为 Java 9 准备的 class 版本，可以运用 Java 9 所提供的特性和库。同时，在早期的 Java 诸版本中使用这个 JAR 也是能运行的，因为较老版本的 Java 只会看到顶层的这个 Helper 类。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>HTML5风格的Java帮助文档、统一JVM日志、I/O流新特性等。<br><a href="http://www.infoq.com/cn/presentations/introduction-of-java9-new-features-jigsaw" target="_blank" rel="noopener">传送门</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;java自1995年诞生到现在已经23岁了，在这么长的时间里，java的每个版本都会带来快一些新的特性，同时还要保持对旧版本的兼容性，因此java的运行时也变得非常臃肿和庞大，运行时依赖的rt.jar单个文件就有60多M，即使你只是想运行一个简单地helloword,你也不得不加载高达60M+的依赖包。随着微服务和自动化运维的兴起，人们讲究的是快速、精细部署，老态龙钟的java却总是差强人意。&lt;br&gt;可以说java9的出现更多的是为了改善这些问题，提升java的竞争力。个人认为java9最大的改善在以下几个方面：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;模块化，避免泛滥的代码依赖和说不清道不明的误用。&lt;/li&gt;&lt;li&gt;Jlink打包，可以生成一个最小依赖的Image，减少包的大小，轻量部署。&lt;/li&gt;&lt;li&gt;提供了类似JShell的新的工具和新的编程API。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="java9" scheme="http://www.geetry.com/categories/java9/"/>
    
    
      <category term="java9初探" scheme="http://www.geetry.com/tags/java9%E5%88%9D%E6%8E%A2/"/>
    
  </entry>
  
  <entry>
    <title>高并发Linux参数优化</title>
    <link href="http://www.geetry.com/2018/02/27/%E9%AB%98%E5%B9%B6%E5%8F%91Linux%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    <id>http://www.geetry.com/2018/02/27/高并发Linux参数优化/</id>
    <published>2018-02-27T06:17:07.000Z</published>
    <updated>2018-05-06T11:37:21.261Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>因为默认的Linux的内核参数考虑的是一般通用的场景，这明显不符合用于支持高并发访问的场景，所以我们需要修改Linux的内核参数，让服务器可以支持更多的连接和并发。</p><a id="more"></a><p>我们这里的地是修改Linux内核参数使得Nginx可以支持更多的并发请求。<code>sysctl.conf</code>是一个允许您改变正在运行中的Linux系统的接口。它包含一些 TCP/IP 堆栈和虚拟内存系统的高级选项， 这可以让有经验的管理员提高引人注目的系统性能，<br>首先，使用vim编辑器打开<code>/etc/sysctl.conf</code> 文件，默认情况下文件里面是没有配置内容的，我们添加内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fs.file-max = 999999</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line">net.ipv4.ip_local_port_range =1024    61000</span><br><span class="line">net.ipv4.tcp_rmem =4096 32768 262142</span><br><span class="line">net.ipv4.tcp_wmem =4096 32768 262142</span><br><span class="line">net.core.netdev_max_backlog = 8096</span><br><span class="line">net.core.rmem_default = 262144</span><br><span class="line">net.core.wmem_default = 262144</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.core.rmem_max = 2097152</span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 1024</span><br></pre></td></tr></table></figure><p>上面参数意义解释如下：</p><ol><li>file-max: 这个参数表示进程可以同时打开的最大文件句柄数，这个参数直接限制最大并发连接数，需要根据实际情况配置。</li><li>tcp_tw_reuse: 这个参数设置为1，表示允许将TIME—WAIT状态的socket重新用于新的TCP连接，这对服务器来说很有意义，因为服务器上总是会有大量的TIME-WAIT状态的连接。</li><li>tcp_keepalive_time: 这个参数表示当keepalive启用时，TCP发送keealive消息的频度。默认是2小时，如果将其设置小一些，可以更快地清理无效的连接。</li><li>tcp_fin_timeout: 这个参数表示当服务器主动关闭连接的时候，socket保持在FIN-WAIT-2状态的最大时间。</li><li>tcp_max_tw_buckets: 这个参数表示操作系统允许TIME_WAIT套接字数量的最大值，如果超过这个数量，套接字将立即被清除并打印警告信息。该参数默认为180000，过多的TIME_WAIT套接字会使得Web服务器变慢。</li><li>tcp_max_syn_backlog: 这个表示TCP三次握手建立阶段服务器接收SYN请求队列的最大长度，默认是1024。将其设置大一些可以使得Nginx繁忙来不及accept新连接的时候不至于丢失客户端发起的连接请求。</li><li>ip_local_port_range: 这个参数定了在UDP和TCP连接本地端口的取值范围。</li><li>tcp_rmem: 这个参数定义了TCP接收缓存（用于TCP接收滑动窗口）的最小值、默认值、最大值</li><li>tcp_wmen: 这个参数定义了TCP发送缓存（用于TCP接收滑动窗口）的最小值、默认值、最大值</li><li>netdev_max_backlog: 当网卡接收数据包的速度大于内核处理数据的时候，会有一个队列保存这些数据包。这个参数表示这个队列的最大值。</li><li>rmem_default：这个参数表示内核套接字接收缓存区默认的大小。</li><li>wmem_default：这个参数表示内核套接字发送缓存区默认的大小。</li><li>rmem_max：这个参数表示内核套接字接收缓存区默认的最大大小。</li><li>wmem_max：这个参数表示内核套接字发送缓存区默认的最大大小。</li><li>tcp_syncookies: 这是一个开关，是否打开SYN Cookie功能，该功能可以防止部分SYN攻击。</li><li>tcp_max_syn_backlog: 端口最大 backlog 内核限制。此参数限制 服务端应用程序 可以设置的端口最大 backlog 值 (对应于端口的 syn_backlog 和 backlog 队列长度)。动机是在内存有限的服务器上限制/避免应用程序配置超大 backlog 值而耗尽内核内存。如果应用程序设置 backlog 大于此值，操作系统将自动将之限制到此值。</li></ol><p>修改完成后执行如下命令让参数立即生效：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/sbin/sysctl -p</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;因为默认的Linux的内核参数考虑的是一般通用的场景，这明显不符合用于支持高并发访问的场景，所以我们需要修改Linux的内核参数，让服务器可以支持更多的连接和并发。&lt;/p&gt;
    
    </summary>
    
      <category term="高性能服务" scheme="http://www.geetry.com/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="Linux参数优化" scheme="http://www.geetry.com/tags/Linux%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>健康减肥</title>
    <link href="http://www.geetry.com/2018/02/27/lanlan/"/>
    <id>http://www.geetry.com/2018/02/27/lanlan/</id>
    <published>2018-02-27T06:17:07.000Z</published>
    <updated>2018-05-06T14:05:34.740Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>工作几年之后，小肚腩越来越明显了，体重也比刚毕业的时候增加了不小，衣服的码数一直在增加，自己也意识到为了健康和更好的生活，必须控制体重了。减肥这件事情说难也难，说容易也容易，难在坚持，<br>坚持下去肯定是会有收获。下面来聊聊我在减肥过程中踩过的坑。刚开始的时候也去买了一些比较火的左旋肉碱和一些减肥茶，喝了好几个月，没什么变化，后面我也就没喝了，在朋友的介绍下办了一张健身卡，<br>晚上下班后跟着老师跳了三四个月的健身操，但是每次做完运动后都会感觉到很饿，本身就是吃货一枚，控制不住，这样也没有减下来，但是身体的曲线是有点变化的，感觉穿衣比以前好看些，身上的肉肉也紧<br>了很多。朋友偶尔会提醒我，控制住嘴巴，晚上不要吃饭，试了几天，我没办法做到晚上不吃东西，饿的胃痛，凌晨会醒来好几次，这样就导致我会没什么精神上班，感觉这个方法不太适用，也就放弃了，这个<br>时候我的体重也是一斤都没有掉下来，这个时候我仔细回顾了一下我的经历，我感觉还是需要运动的，但是不控制嘴巴也不行，我就修改成，每餐都少吃一点，每顿只吃原来的70%，而且多吃蔬菜少吃肉，由于我<br>本身就不喜欢吃肥肉，基本上都是买些瘦肉吃，彻底戒掉饮料，只能喝白开水。每餐少吃一点，每餐之间还是会饿，怎么办？特别是下午，给自己加了一顿下午茶，不过也限制的种类，只能是玉米、红薯和蔬菜。<br>这些当然是在网上搜索到的，而且还学会了看每件商品后面的热量，热量越高，我们吃进去的热量就会越高，所以我会尽量挑选一些热量低的食物。这样坚持了两个月之后，惊奇的发现自己居然减下来，体重下<br>降了四斤。oh，myGod，有效果哦，效果很明显有木有，我就这样坚持下去四个月，中国最大的节日来了，春节，大家都吃的，过年胖五斤，过年的时候我也破戒的很厉害，十天的时间差不多都是胡吃海喝的，回<br>工作地方的时候神奇的发现，自己的体重居然没有增加。节后又开始了我的减肥大计了，不求快，但求稳。不求多瘦，但求健康。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;工作几年之后，小肚腩越来越明显了，体重也比刚毕业的时候增加了不小，衣服的码数一直在增加，自己也意识到为了健康和更好的生活，必须控制体重了。减肥这件事情
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://www.geetry.com/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="健身" scheme="http://www.geetry.com/tags/%E5%81%A5%E8%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>扩展hexo-qiniu-sync插件支持自动资源文件</title>
    <link href="http://www.geetry.com/2018/01/14/hexo-qiniu2/"/>
    <id>http://www.geetry.com/2018/01/14/hexo-qiniu2/</id>
    <published>2018-01-14T06:46:24.000Z</published>
    <updated>2018-05-06T11:37:21.259Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>前面在搭建个人博客的时候使用了<code>hexo-qiniu-sync</code>来对接七牛存储，自动完成图片、css和js的上传以及标签解析。<br>但是我们写技术博客的时候经常会附加一些代码文件或者压缩包之类的，我就想能否扩展一下这个插件也让它能够自动帮我们完成上传和标签解析。</p><a id="more"></a><p>所以，我fork原作者的代码，并修改了源代码，放在<a href="https://github.com/liushuishang/hexo-qiniu-sync" target="_blank" rel="noopener">这里</a>，对原作者表示感谢。<br>我同时把修改后的插件上传到了npm，只要通过一下命令安装即可：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-qiniu-sync2 --save</span><br></pre></td></tr></table></figure><p></p><p>用法：<br>其他用法参考源插件，资源文件使用的地方插入<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% qnAsset test.txt title:'测试资源文件' alt:'测试文件' %&#125;</span><br></pre></td></tr></table></figure><p></p><p>生成的html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">title</span>=<span class="string">"测试资源文件"</span> <span class="attr">alt</span>=<span class="string">"测试文件"</span> <span class="attr">href</span>=<span class="string">"http://p24hn6n30.bkt.clouddn.com/static/asset/test.txt"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"noopener"</span>&gt;</span>测试资源文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;前面在搭建个人博客的时候使用了&lt;code&gt;hexo-qiniu-sync&lt;/code&gt;来对接七牛存储，自动完成图片、css和js的上传以及标签解析。&lt;br&gt;但是我们写技术博客的时候经常会附加一些代码文件或者压缩包之类的，我就想能否扩展一下这个插件也让它能够自动帮我们完成上传和标签解析。&lt;/p&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://www.geetry.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="http://www.geetry.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Mybatis实现事务内多数据源切换2</title>
    <link href="http://www.geetry.com/2018/01/13/SpringMybatisMutilDataSource2/"/>
    <id>http://www.geetry.com/2018/01/13/SpringMybatisMutilDataSource2/</id>
    <published>2018-01-13T14:21:52.000Z</published>
    <updated>2018-05-06T11:37:21.257Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p><a href="http://www.geetry.com/2018/01/13/SpringMybatisMutilDatasource">上一篇</a>我介绍了如何在SpringBoot+Mybatis中实现多数据源的动态切换。这一篇我将介绍为什么自动切换在事务笼罩下的Service方法内会失效，并说明其解决办法，好，让我们开始。</p><a id="more"></a><h1 id="问题缘由"><a href="#问题缘由" class="headerlink" title="问题缘由"></a>问题缘由</h1><p>首先让我们先配置一个事物管理器以及它的AOP拦截切面：<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"create*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"add*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"modify*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"edit*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"remove*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"send*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">rollback-for</span>=<span class="string">"Exception"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"query*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"search*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"select*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"count*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"list*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"load*"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--&lt;tx:method name="*" propagation="REQUIRED"   isolation="REPEATABLE_READ"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置拦截所有xxxService中的public方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">expose-proxy</span>=<span class="string">"true"</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">"execution(public * com.smartdata360..service.*Service.*(..))"</span> <span class="attr">id</span>=<span class="string">"pt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span> <span class="attr">order</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>当我们配置了事物管理器和拦截Service中的方法后，每次执行Service中方法前会开启一个事务，<br>并且同时会缓存一些东西：DataSource、SqlSessionFactory、Connection等<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm005.png-blogImg"><br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm006.png-blogImg"></p><p>所以，我们在外面再怎么设置要求切换数据源也没用，因为Conneciton都是从缓存中拿的，所以我们要想能够顺利的切换数据源，实际就是能够动态的根据DatabaseType获取不同的Connection，并且要求不能影响整个事物的特性。</p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><p>我们既想实现动态的获取不同的Connection对象，又不想破坏事务的特性，那怎么办？我想到的办法就是重写事物管理器。SpringBoot中默认用到的是SpringManagedTransactionFactory这个工厂类来创建事务对象SpringManagedTransaction<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm007.png-blogImg"><br>而事务对象有我要的方法<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm008.png-blogImg"><br>所以我决定改写这两个类，首先是重写一个Transaction类的实现，它封装了怎么获取Connection对象。<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm009.png-blogImg"></p><ol><li>dataSource保持了当前的数据源对象，实际就是DynamicDataSource</li><li>mainConnecition表示当前事务对应的Connection</li><li>mainDatabaseIdentification表示当前事务对应的数据源标识</li><li>otherConnectionMap表示Service中用到的其他的数据源Connection对象</li></ol><p>首先看我们如何获取一个Conneciton对象：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DatabaseType databaseType = DatabaseContextHolder.getDatabaseType();</span><br><span class="line"><span class="comment">//        notNull(databaseType, "DatabaseType can not be null");</span></span><br><span class="line">        <span class="keyword">if</span> (databaseType == <span class="keyword">null</span>) databaseType = DatabaseType.getDefault();</span><br><span class="line">        String databaseIdentification = databaseType.getValue();</span><br><span class="line">        <span class="keyword">if</span> (databaseIdentification.equals(mainDatabaseIdentification)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mainConnection != <span class="keyword">null</span>) <span class="keyword">return</span> mainConnection;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                openMainConnection();</span><br><span class="line">                mainDatabaseIdentification =databaseIdentification;</span><br><span class="line">                <span class="keyword">return</span> mainConnection;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取其他的数据源连接</span></span><br><span class="line">            <span class="keyword">if</span> (!otherConnectionMap.containsKey(databaseIdentification)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Connection conn = dataSource.getConnection();</span><br><span class="line">                    otherConnectionMap.put(databaseIdentification, conn);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CannotGetJdbcConnectionException(<span class="string">"Could not get JDBC Connection"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> otherConnectionMap.get(databaseIdentification);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openMainConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mainConnection = DataSourceUtils.getConnection(<span class="keyword">this</span>.dataSource);</span><br><span class="line">        <span class="keyword">this</span>.autoCommit = <span class="keyword">this</span>.mainConnection.getAutoCommit();</span><br><span class="line">        <span class="keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="keyword">this</span>.mainConnection, <span class="keyword">this</span>.dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">            LOGGER.debug(</span><br><span class="line">                    <span class="string">"JDBC Connection ["</span></span><br><span class="line">                            + <span class="keyword">this</span>.mainConnection</span><br><span class="line">                            + <span class="string">"] will"</span></span><br><span class="line">                            + (<span class="keyword">this</span>.isConnectionTransactional ? <span class="string">" "</span> : <span class="string">" not "</span>)</span><br><span class="line">                            + <span class="string">"be managed by Spring"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p></p><p>首先从当前线程变量中获取DatabaseType，然后取到当前的数据源标识，如果是mainDatabaseIdentification那么就从事务中获取事务自己管理的Connection；否则使用dataSource获取一个并且缓存起来（这时候会触发determineCurrentLookupKey方法的执行），避免重复获取。这样我们在外面设置的DatabaseType已经渗透到事物管理器内部了，也实现了Connection对象的动态获取。<br>但是我们不能改变事务处理的特性，所以其他的副Connection的状态应该与mainConnection保持一致，同样我改写了其他几个方法：<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm010.png-blogImg"></p><p>这样所有的Connection的状态与当前事务是一致的了。之前想过atomikos来实现分布式事务；我不确定我这种方法能否做到同一个事务在多个数据库上的一致性和隔离性。<br>好，核心的东西介绍完成了，那么我们怎么和Mybaits结合呢？很简单，我们也实现一个工厂类创建我们自己的事务处理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持Service内多数据源切换的Factory</span></span><br><span class="line"><span class="comment"> * Created by  yuananyun on 2017/7/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDataSouceTransactionFactory</span> <span class="keyword">extends</span> <span class="title">SpringManagedTransactionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> autoCommit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Transaction <span class="title">newTransaction</span><span class="params">(DataSource dataSource, TransactionIsolationLevel level, <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MultiDataSourceTransaction(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后把这个工厂类挂到Mybatis的配置方法里面去：<br><img title="事务处理" alt="事务处理" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm011.png-blogImg"></p><p>如此，大功告成，附带<code>MultiDataSourceTransaction</code>类的源码<br><a href="http://p24hn6n30.bkt.clouddn.com/static/java/sbmm2MultiDataSourceTransaction.java" target="_blank" rel="noopener">MultiDataSourceTransaction</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&lt;a href=&quot;http://www.geetry.com/2018/01/13/SpringMybatisMutilDatasource&quot;&gt;上一篇&lt;/a&gt;我介绍了如何在SpringBoot+Mybatis中实现多数据源的动态切换。这一篇我将介绍为什么自动切换在事务笼罩下的Service方法内会失效，并说明其解决办法，好，让我们开始。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.geetry.com/categories/java/"/>
    
    
      <category term="SpringBoot,Mybatis,多数据源切换" scheme="http://www.geetry.com/tags/SpringBoot-Mybatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot+Mybatis实现事务内多数据源切换1</title>
    <link href="http://www.geetry.com/2018/01/13/SpringMybatisMutilDatasource/"/>
    <id>http://www.geetry.com/2018/01/13/SpringMybatisMutilDatasource/</id>
    <published>2018-01-13T03:41:01.000Z</published>
    <updated>2018-05-06T11:37:21.258Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>目前SpringBoot+Mybatis使用人的还比较多，我们项目有需求在一个项目中使用多个数据源，所以我就借助于Spring提供的AbstractRoutingDataSource类实现了多数据源的切换。一切都很好，直到遇到了事务处理内的数据源切换，因为一个事务处理开始的时候就会把DataSource、Connection给缓存了，所以不管你在外面怎么配置切换，都不能实现connection的切换。经过查看和调试源代码，总算是找到了一条解决的路，现在写出来供需要的朋友做参考。<br>我的计划是写两篇文章来说明这个事情，第一篇主要是介绍如何实现项目中多数据源的切换；第二篇主要是介绍如何解决事务中数据源的动态切换。</p><a id="more"></a><h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>我们首先来看看动态数据源动态切换的原理:<br><img title="多数据源动态切换原理图" alt="多数据源动态切换原理图" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm001.png-blogImg"><br>如上图所示，我们使用一个DynamicDataSource这个数据源来代理多个数据源，让上层感知不到后面的多个数据源，然后我们在线程上下文中根据需要来动态切换使用真正的数据源，那么就可以用常规的方法解决了多数据源的读取了。<br>感谢Spring为我们提供了这么一个代理数据源类：AbstractRoutingDataSource。该类有个方法用于在每次连接数据库的时候获取目标数据源:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DataSource <span class="title">determineTargetDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.resolvedDataSources, <span class="string">"DataSource router not initialized"</span>);</span><br><span class="line">Object lookupKey = determineCurrentLookupKey();</span><br><span class="line">DataSource dataSource = <span class="keyword">this</span>.resolvedDataSources.get(lookupKey);</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span> &amp;&amp; (<span class="keyword">this</span>.lenientFallback || lookupKey == <span class="keyword">null</span>)) &#123;</span><br><span class="line">dataSource = <span class="keyword">this</span>.resolvedDefaultDataSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot determine target DataSource for lookup key ["</span> + lookupKey + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们可以实现determineCurrentLookupKey这个方法来注入我们的数据源选择逻辑，比如我的一个实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DatabaseType type = DatabaseContextHolder.getDatabaseType();</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="keyword">null</span>) type = DatabaseType.getDefault();</span><br><span class="line">    <span class="keyword">return</span> type.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DatabaseType是一个自定义的Enum对象，只是为了区分不同的数据源而已。DatabaseContextHolder也是一个自定义类，目的是保持每个线程的各自的独立变量，你可能猜到了与ThreadLocal有关。<br><img title="DatabaseType" alt="DatabaseType" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm002.png-blogImg"><br><img title="DatabaseContextHolder" alt="DatabaseContextHolder" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm003.png-blogImg"></p><p>使用的时候在项目中配置多个数据源：<br><img title="配置多个数据源" alt="配置多个数据源" src="http://p24hn6n30.bkt.clouddn.com/static/images/sbmm004.png-blogImg"></p><p>我这里配置了两个数据源，对应到第一张图，很明显了吧。<br>好，工具都准备好了，现在看我们怎么用。首先我们肯定是在获取数据源的Connection之前设置好使用的DatabaseType，并且这个变量是与当前线程绑定的；然后DynamicDataSource在获取Conneciton的时候会通过方法determineCurrentLookupKey来获取一个真正的DataSource来开启一个Conneciton；接下来就是交给Mybaitis来完成数据库操作了。那么我们在哪里设置这个DatabaseType呢？每次需要切换前？这肯定没错，但是手工操作也太low了，所以我这里写了一个AOP方法来自动设置这个标识：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.smartdata360..mapper.*Mapper.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">datasourcePoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"datasourcePoint()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">handler</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Signature signature = point.getSignature();</span><br><span class="line">        MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">        Method method = methodSignature.getMethod();</span><br><span class="line"></span><br><span class="line">        MultiDataSource multiDataSource = method.getAnnotation(MultiDataSource.class);</span><br><span class="line">        <span class="keyword">if</span> (multiDataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = method.getDeclaringClass();</span><br><span class="line">            multiDataSource = clazz.getAnnotation(MultiDataSource.class);</span><br><span class="line">        &#125;</span><br><span class="line">        DatabaseType databaseType = DatabaseType.getDefault();</span><br><span class="line">        <span class="keyword">if</span> (multiDataSource != <span class="keyword">null</span>)</span><br><span class="line">            databaseType = multiDataSource.value();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DatabaseContextHolder.setDatabaseType(databaseType);</span><br><span class="line">            Object result = point.proceed();</span><br><span class="line">            DatabaseContextHolder.clearDatabaseType();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            DatabaseContextHolder.clearDatabaseType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我指定我拦截所有Mapper类的所有方法，也就是我们的数据源切换是Mapper级别的；然后我从类或方法签名上查找MultiDataSource这个标注，如果有，那么直接取出设置的值，如果没有，那么直接设置primary为默认数据源；最后一步就是执行完后要清理一下这个标识，免得给下一次执行造成影响。这样我们就可以用给类或方法打标注的方式来决定我们使用哪个数据源了，如果没指定那么直接默认用primary数据源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MultiDataSource</span>(DatabaseType.second)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NativeMapper</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select address from dim_card_native where id=#&#123;idcard&#125; limit 1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">selectOne</span><span class="params">(@Param(<span class="string">"idcard"</span>)</span> String idcard)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *插入缺失的身份证籍贯</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idCard</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"insert into dim_card_native(id,address) select #&#123;idcard&#125;,' ' "</span> +</span><br><span class="line">            <span class="string">" where not exists(select id from dim_card_native where id=#&#123;idcard&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insetBlankCard</span><span class="params">(@Param(<span class="string">"idcard"</span>)</span> String idCard)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一切就是这么简单得实现了多数据源的自动切换，但是当我们在Service上开启事务的时候就会出问题了：切换数据源失效！原因和如何解决请看下一篇的讲解。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;目前SpringBoot+Mybatis使用人的还比较多，我们项目有需求在一个项目中使用多个数据源，所以我就借助于Spring提供的AbstractRoutingDataSource类实现了多数据源的切换。一切都很好，直到遇到了事务处理内的数据源切换，因为一个事务处理开始的时候就会把DataSource、Connection给缓存了，所以不管你在外面怎么配置切换，都不能实现connection的切换。经过查看和调试源代码，总算是找到了一条解决的路，现在写出来供需要的朋友做参考。&lt;br&gt;我的计划是写两篇文章来说明这个事情，第一篇主要是介绍如何实现项目中多数据源的切换；第二篇主要是介绍如何解决事务中数据源的动态切换。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.geetry.com/categories/java/"/>
    
    
      <category term="SpringBoot,Mybatis,多数据源切换" scheme="http://www.geetry.com/tags/SpringBoot-Mybatis-%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E5%88%87%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>hexo集成hexo-qiniu-sync插件</title>
    <link href="http://www.geetry.com/2018/01/06/hexo-qiniu/"/>
    <id>http://www.geetry.com/2018/01/06/hexo-qiniu/</id>
    <published>2018-01-06T11:46:24.000Z</published>
    <updated>2018-05-06T11:37:21.256Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>今天抽空在博客中集成hexo-qiniu-sync插件，主要目的是想把博客中用到的资源，比如图片、文件等放到七牛云存储，这样博客中只要通过url引用资源就行了，不仅方便而且安全。</p><blockquote><p>hexo-qiniu-sync是一个hexo插件， 可以让你在文档中入嵌存储在七牛上的图片、JS、CSS类型的静态文件。你可以不用手动上传文件到七牛，插件会自动帮你将本地目录的文件同步到七牛。</p></blockquote><p><a href="http://github.com/gyk001/hexo-qiniu-sync" target="_blank" rel="noopener">项目地址</a></p><a id="more"></a><p>环境要求：</p><ol><li>已经安装好了nodejs和npm</li><li>已经初始化一个hexo博客目录</li><li><p>已经安装了git，并且关联到了github</p><p>所有的以上要求可以<a href="https://www.jianshu.com/p/189fd945f38f" target="_blank" rel="noopener">参考这里</a>来完成。<br>在hexo初始化后的博客根目录执行如下语句来安装插件：</p><blockquote><p>npm install hexo-qiniu-sync –save</p></blockquote></li></ol><h1 id="开通七牛存储"><a href="#开通七牛存储" class="headerlink" title="开通七牛存储"></a>开通七牛存储</h1><p>可以点击<a href="https://portal.qiniu.com/signup?code=3ll7lbuke1iky" target="_blank" rel="noopener">这里</a>来注册七牛存储，免费个人有10G的存储空间，个人博客应该足够使用了。<br>注册成功后，进入”资源主页”添加一个”对象存储”来存放我们的博客资源。<br><img title="添加对象存储" alt="添加对象存储" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu001.png-blogImg"><br>存储空间名称写”yayblog”,选择华南地区、公开空间创建一个对象存储。点击刚创建的存储空间查看空间信息：<br><img title="对象存储详情" alt="对象存储详情" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu002.png-blogImg"><br>其中”内容管理”可以管理存储空间中的内容；”图片样式”可以为上传的图片做一些处理，比如剪裁、压缩、加水印等；七牛还给了一个测试域名，你也可以绑定自己的域名，但是需要中国特色的 “备案”，我使用的国外的域名，所以这里用得是这个测试域名。<br>在”个人中心”可以查看刚自己的AccessKey/SecretKey，这个是七牛颁发的凭证，稍后配置的时候会使用。<br><img title="密钥查看" alt="密钥查看" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu003.png-blogImg"><br>至此，七牛存储已经准备就绪，我们重新回到我们的博客目录。</p><h1 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h1><p>打开根目录的<code>_config.yml</code>,添加如下配置：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#plugins:</span><br><span class="line">#- hexo-qiniu-sync</span><br><span class="line"></span><br><span class="line">#七牛云存储设置</span><br><span class="line">##offline       是否离线. 离线状态将使用本地地址渲染</span><br><span class="line">##sync          是否同步</span><br><span class="line">##bucket        空间名称.</span><br><span class="line">##access_key    上传密钥AccessKey</span><br><span class="line">##secret_key    上传密钥SecretKey</span><br><span class="line">##secret_file   秘钥文件路径，可以将上述两个属性配置到文件内，防止泄露，json格式。绝对路径相对路径均可</span><br><span class="line">##dirPrefix     上传的资源子目录前缀.如设置，需与urlPrefix同步</span><br><span class="line">##urlPrefix     外链前缀.</span><br><span class="line">##up_host      上传服务器路径,如选择华北区域的话配置为http://up-z1.qiniu.com</span><br><span class="line">##local_dir     本地目录.</span><br><span class="line">##update_exist  是否更新已经上传过的文件(仅文件大小不同或在上次上传后进行更新的才会重新上传)</span><br><span class="line">##image/js/css  子参数folder为不同静态资源种类的目录名称，一般不需要改动</span><br><span class="line">##image.extend  这是个特殊参数，用于生成缩略图或加水印等操作。具体请参考http://developer.qiniu.com/docs/v6/api/reference/fop/image/</span><br><span class="line">##              可使用基本图片处理、高级图片处理、图片水印处理这3个接口。例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图</span><br><span class="line">qiniu:</span><br><span class="line">  offline: false</span><br><span class="line">  sync: true</span><br><span class="line">  bucket: yayblog</span><br><span class="line">  secret_file: null</span><br><span class="line">  access_key: 七牛给的密钥</span><br><span class="line">  secret_key: 七牛给的密钥</span><br><span class="line">  dirPrefix: static</span><br><span class="line">  urlPrefix: http://前面七牛给的测试域名/static</span><br><span class="line">  up_host: http://upload.qiniu.com</span><br><span class="line">  local_dir: static</span><br><span class="line">  update_exist: true</span><br><span class="line">  image:</span><br><span class="line">    folder: images</span><br><span class="line">    extend: </span><br><span class="line">  js:</span><br><span class="line">    folder: js</span><br><span class="line">  css:</span><br><span class="line">    folder: css</span><br></pre></td></tr></table></figure><p></p><p>这里要注意的是，参考作者的文档，会报错，正常的是不需要在这里写插件注册，也就是注释以下语句：</p><blockquote><p>#plugins:<br>#- hexo-qiniu-sync</p></blockquote><p>这个插件的原理就是指定一个本地的目录<code>local_dir</code>和七牛对象存储的一个目录做映射，当发现本地目录中文件有变化的时候就自动上传到配置好的七牛的对象存储空间。<br>根据作者的说法，这个本地<code>local_dir</code>是会自动创建的，但是不知道他有没有测试macos系统的情况。经过测试会出现权限不足的情况，所以需要执行命令把整个文件夹授权给当前用户，比如简单粗暴：</p><blockquote><p>chmod a+rwx .</p></blockquote><p>万一真的不行，我还可以手动创建，但是需要注意新建的<code>static</code>文件夹的位置要和<code>source</code>平级，而不是<code>source</code>里面：<br><img title="static目录" alt="static目录" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu004.png-blogImg"><br>通过以上配置后，我们在static/images里面添加一张图片，然后执行命令：</p><blockquote><p>hexo qiniu sync</p></blockquote><p>就会在七牛网站对应的对象存储内容里面看到上传的图片啦<br><img title="上传的图片" alt="上传的图片" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu005.png-blogImg"><br>至此，我们已经完成了这个插件的配置，在markdown中使用图片：</p><blockquote><img title="上传的图片" alt="上传的图片" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu005.png-blogImg"></blockquote><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1><p>还记得我们前面的配置项里面有个<code>image : extend</code>的参数吗，这个是给图片处理预留的，也就是七牛可以自动对上传的图片做处理。</p><blockquote><p>可以使用 基本图片处理（imageView2）、高级图片处理（imageMogr2）、图片水印处理（watermark） 这三个图片处理接口，多个接口内容之间用 | 间隔。<br>例如 ?imageView2/2/w/500 即生成宽度最多500px的缩略图。</p></blockquote><p>以图片水印为例，我需要在我博客里面的图片上加上站点url的水印。首先我们在七牛的对象存储配置一个图片样式<code>blogImg</code>：<br><img title="新建图片样式" alt="新建图片样式" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu006.png-blogImg"><br><img title="新建图片样式" alt="新建图片样式" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu007.png-blogImg"><br>完成后，回到博客根目录的配置文件修改配置项：</p><blockquote><p>extend: -blogImg</p></blockquote><p>这样当我们下载或引用图片的时候会自动加上了设置的水印。这是一个全局的配置，可能我们不是所有的图片都需要水印，这种情况我们可以在七牛创建多个图片样式，然后再引用图片的时候指定<code>extend</code>来指定生效的图片样式，标签中的设置会覆盖全局的设置，如：<br><img title="水印样式" alt="水印样式" src="http://p24hn6n30.bkt.clouddn.com/static/images/qiniu008.png"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;今天抽空在博客中集成hexo-qiniu-sync插件，主要目的是想把博客中用到的资源，比如图片、文件等放到七牛云存储，这样博客中只要通过url引用资源就行了，不仅方便而且安全。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;hexo-qiniu-sync是一个hexo插件， 可以让你在文档中入嵌存储在七牛上的图片、JS、CSS类型的静态文件。你可以不用手动上传文件到七牛，插件会自动帮你将本地目录的文件同步到七牛。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://github.com/gyk001/hexo-qiniu-sync&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="博客搭建" scheme="http://www.geetry.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="hexo" scheme="http://www.geetry.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>开通个人博客</title>
    <link href="http://www.geetry.com/2018/01/06/first/"/>
    <id>http://www.geetry.com/2018/01/06/first/</id>
    <published>2018-01-06T09:33:28.000Z</published>
    <updated>2018-05-06T11:37:21.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --><p>&nbsp;&nbsp;&nbsp;&nbsp;一直断断续续在<a href="http://www.cnblogs.com/yuananyun" target="_blank" rel="noopener">博客园</a>写了将近七年的博客，期间也换了几次电脑了，所发的博文的原文也都丢了，此外，第三方博客平台终究不是那么自由，个人站点更适合作为个人名片。<br>&nbsp;&nbsp;&nbsp;&nbsp;后来github出现了，有想法把博文建立一个repository，这样不仅可以永久保留原文，而且还可以跟踪不同的版本，方便修改和完善。<br>&nbsp;&nbsp;&nbsp;&nbsp;再后来出现了hexo这个非常good的项目，可以直接把博文编译成静态html，然后很方便的部署到网页服务器（比如github的pages、nginx等）。<br>&nbsp;&nbsp;&nbsp;&nbsp;今天，作为程序员使用最多的编辑器肯定是Eclipse和IDEA之类的代码编辑器，然后我又有了用IDEA写博客的想法。写代码的时候突然有了灵感想写一篇博客，然后直接在IDEA里面new一个文件，拍拍拍，一气呵成，一键更新，快哉！<br>&nbsp;&nbsp;&nbsp;&nbsp;2018年来临了，今年给自己的规划是：多读书，多写博客，早睡早起身体好。所以花了几天搭建了这个博客站点，作为一个新的开始罢。我是一只奋斗中的眼镜兔，请记住我的头像：<br><img title="我的头像" alt="奋斗的眼镜兔" src="http://p24hn6n30.bkt.clouddn.com/static/images/头像.jpeg"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun May 06 2018 22:09:29 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;一直断断续续在&lt;a href=&quot;http://www.cnblogs.com/yuananyun&quot; t
      
    
    </summary>
    
      <category term="人生感悟" scheme="http://www.geetry.com/categories/%E4%BA%BA%E7%94%9F%E6%84%9F%E6%82%9F/"/>
    
    
      <category term="碎碎念" scheme="http://www.geetry.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
</feed>
